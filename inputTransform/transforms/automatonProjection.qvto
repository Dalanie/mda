modeltype BMO uses 'http://www.studieren.se/behaviour_projection';
modeltype IOM uses 'http://www.studieren.se/automaton_projection';

transformation automatonProjection(in bmo : BMO, out iom : IOM);

property inputsAlreadyInserted : Set(String);

	
main() {
	mergeLifelineBehaviours(bmo.objectsOfType(Behaviour))-> map mapBehaviour();
}

helper mergeLifelineBehaviours(inBehaviours : Set(Behaviour)) : Set(Behaviour){
	var outBehaviours : Set(Behaviour);
	
	inBehaviours->forEach(behaviour) {
		var existentBehaviour : Behaviour = findBehaviourOfLifeline(outBehaviours, behaviour.Lifeline.Name);
		
		if(existentBehaviour = null) {
			// Behaviour doesn't exist yet; add
			outBehaviours += behaviour;
		} else {
			// Behaviour already exists; merge
			behaviour.Block->forEach(block) {
				existentBehaviour.Block += block;
			}
		}
	};
	
	return outBehaviours;
}

helper findBehaviourOfLifeline(behaviours : Set(Behaviour), lifelineName : String) : Behaviour {
	behaviours->forEach(behaviour) {
		if(behaviour.Lifeline.Name.=(lifelineName)) {
			return behaviour;
		}
	};
	
	return null;
}

helper getStatesOfBehaviour(behaviour : Behaviour) : Set(IOAutomaton::State) {
	var states : Set(IOAutomaton::State);
	behaviour.Block->forEach(block) {
		if(not containsStateWithName(states, block.PreState.Name)) {
			states += block.PreState-> map mapState();
		};
		if(not containsStateWithName(states, block.PostState.Name)) {
			states += block.PostState-> map mapState();
		};
	};
	
	return states;
}

helper containsStateWithName(states : Set(IOAutomaton::State), stateName : String) : Boolean {
	states->forEach(state) {
		if(state.Name.=(stateName)) {
			return true;
		}
	};
	
	return false;
}

helper containsInput(inputs : Set(IOAutomaton::Input), probeInput : IOAutomaton::Input) : Boolean {
	inputs->forEach(input) {
		if(input.Operation.Name = (probeInput.Operation.Name)) {
			return true;
		}
	};
	
	return false;
}

helper getInputsFromTransitions(transitions : Set(IOAutomaton::Transition)) : Set(IOAutomaton::Input) {
	var inputs : Set(IOAutomaton::Input);
	transitions->forEach(transition) {
		if(not containsInput(inputs, transition.Input)) {
			inputs += transition.Input;
		}
	};
	return inputs;
}

helper containsOutput(outputs : Set(IOAutomaton::Output), probeOutput : IOAutomaton::Output) : Boolean {
	outputs->forEach(output) {
		if(output.Operation.Name.=(probeOutput.Operation.Name)) {
			return true;
		}
	};
	
	return false;
}

/*helper getOutputsFromTransitions(transitions : Set(IOAutomaton::Transition)) : Set(IOAutomaton::Output) {
	var outputs : Set(IOAutomaton::Output);
	transitions->forEach(transition) {
		transition.Activation.Output->forEach(output) {
			if(not containsOutput(outputs, output)) {
				outputs += output;
			}
		}
	};
	return outputs;
}*/

helper getAutomatonState(states : Set(IOAutomaton::State), inputState : BehaviourProjection::State) : IOAutomaton::State {
	states->forEach(state) {
		if(state.Name.=(inputState.Name)) {
			return state;
		}
	};
	
	return null;
}

mapping BehaviourProjection::State::mapState() : IOAutomaton::State {
	result.Name := self.Name;
}


mapping Behaviour::mapBehaviour() : Automaton {
	log("Mapping Behaviour to Automaton " + self.Lifeline.Name);
	
	result.Name := self.Lifeline.Name;
	
	result.Z := getStatesOfBehaviour(self);
	//result.In := getInputsFromTransitions(result.Delta);
	result.In := self.Block.InMessage.map mapInMessage();
	result.Delta := self.Block->map mapBlock(result);
	result.Out := self.Block.Activation.map mapActivation();
	result.Z0 := self.Block->at(1).PreState.map mapState();
}

mapping Block::mapBlock(automaton : IOAutomaton::Automaton) : Transition {
	result.PreState := getAutomatonState(automaton.Z, self.PreState);
	result.PostState := getAutomatonState(automaton.Z, self.PostState);
	result.Input := automaton.In->select(e | e.Operation.Name = self.InMessage.Operation.Name)->asSequence()->at(1);
		//.deepclone().oclAsType(IOAutomaton::Input);
	result.Activation := self.Activation.map mapActivation();
}

mapping BehaviourProjection::InMessage::mapInMessage() : IOAutomaton::Input

when { not inputsAlreadyInserted->includes(self.Operation.Name) 
}{
	inputsAlreadyInserted := inputsAlreadyInserted->including(self.Operation.Name);
	result.Operation := self.Operation.map mapOperation();
	result.Name := result.Operation.Name;
}

mapping BehaviourProjection::Operation::mapOperation() : IOAutomaton::Operation {
	result.Name := self.Name;
}

mapping BehaviourProjection::Activation::mapActivation() : IOAutomaton::Activation {
	result.Output := self.OutMessage->map mapOutMessage();
	result.Return := self.ReturnValue.map mapReturn();
}

mapping BehaviourProjection::OutMessage::mapOutMessage() : IOAutomaton::Output {
	result.Operation := self.Operation.map mapOperation();
	result.Name := result.Operation.Name;
	result.Object := self.Object.map mapObject();
	result.Return := self.ReturnValue.map mapReturn();
}
mapping BehaviourProjection::Object::mapObject() : IOAutomaton::Object {
	result.Name := self.Name;	
}
mapping BehaviourProjection::Return::mapReturn() : IOAutomaton::ReturnValue {
	result.Name := self.Name;
	result.IsVoid := self.IsVoid;
}
