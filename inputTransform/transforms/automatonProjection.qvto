modeltype BMO uses 'http://www.studieren.se/behaviour_projection';
modeltype IOM uses 'http://www.studieren.se/automaton_projection';

transformation automatonProjection(in bmo : BMO, out iom : IOM);

main() {
	mergeLifelineBehaviours(bmo.objectsOfType(Behaviour))-> map mapBehaviour();
}

helper mergeLifelineBehaviours(inBehaviours : Set(Behaviour)) : Set(Behaviour){
	var outBehaviours : Set(Behaviour);
	
	inBehaviours->forEach(behaviour) {
		var existentBehaviour : Behaviour = findBehaviourOfLifeline(outBehaviours, behaviour.Lifeline.Name);
		
		if(existentBehaviour = null) {
			// Behaviour doesn't exist yet; add
			outBehaviours += behaviour;
		} else {
			// Behaviour already exists; merge
			behaviour.Block->forEach(block) {
				existentBehaviour.Block += block;
			}
		}
	};
	
	return outBehaviours;
}

helper findBehaviourOfLifeline(behaviours : Set(Behaviour), lifelineName : String) : Behaviour {
	behaviours->forEach(behaviour) {
		if(behaviour.Lifeline.Name.=(lifelineName)) {
			return behaviour;
		}
	};
	
	return null;
}

helper getStatesOfBehaviour(behaviour : Behaviour) : Set(IOAutomaton::State) {
	var states : Set(IOAutomaton::State);
	behaviour.Block->forEach(block) {
		if(not containsStateWithName(states, block.PreState.Name)) {
			states += block.PreState-> map mapState();
		};
	};
	
	return states;
}

helper containsStateWithName(states : Set(IOAutomaton::State), stateName : String) : Boolean {
	states->forEach(state) {
		if(state.Name.=(stateName)) {
			return true;
		}
	};
	
	return false;
}

mapping BehaviourProjection::State::mapState() : IOAutomaton::State {
	result.Name := self.Name;
}


mapping Behaviour::mapBehaviour() : Automaton {
	log("Mapping Behaviour to Automaton " + self.Lifeline.Name);
	
	
	result.Z := getStatesOfBehaviour(self);
	result.Delta := self.Block->map mapBlock();
}

mapping Block::mapBlock() : Transition {
	result.PreState := self.PreState.map mapState();
	result.PostState := self.PostState.map mapState();
	result.Input := self.InMessage.map mapInMessage();
	result.Activation := self.Activation.map mapActivation();
}

mapping BehaviourProjection::InMessage::mapInMessage() : IOAutomaton::Input {
	result.Operation := self.Operation.map mapOperation();
}

mapping BehaviourProjection::Operation::mapOperation() : IOAutomaton::Operation {
	result.Name := self.Name;
}

mapping BehaviourProjection::Activation::mapActivation() : IOAutomaton::Activation {
	result.Output := self.OutMessage->map mapOutMessage();
	result.Return := self.ReturnValue.map mapReturn();
}

mapping BehaviourProjection::OutMessage::mapOutMessage() : IOAutomaton::Output {
	result.Operation := self.Operation.map mapOperation();
	result.Return := self.ReturnValue.map mapReturn();
}

mapping BehaviourProjection::Return::mapReturn() : IOAutomaton::ReturnValue {
	result.Name := self.Name;
	result.IsVoid := self.IsVoid;
}
