modeltype BMO uses 'http://www.studieren.se/behaviour_projection';
modeltype IOM uses 'http://www.studieren.se/automaton_projection';

transformation automatonProjection(in bmo : BMO, out iom : IOM);

property inputsAlreadyInserted : Set(String);
property outputsAlreadyInserted : Set(IOAutomaton::Activation);

	
main() {
	mergeLifelineBehaviours(bmo.objectsOfType(Behaviour))-> map mapBehaviour();
}

helper mergeLifelineBehaviours(inBehaviours : Set(Behaviour)) : Set(Behaviour){
	var outBehaviours : Set(Behaviour);
	
	inBehaviours->forEach(behaviour) {
		var existentBehaviour : Behaviour = findBehaviourOfLifeline(outBehaviours, behaviour.Lifeline.Name);
		
		if(existentBehaviour = null) {
			// Behaviour doesn't exist yet; add
			outBehaviours += behaviour;
		} else {
			// Behaviour already exists; merge
			behaviour.Block->forEach(block) {
				existentBehaviour.Block += block;
			}
		}
	};
	
	return outBehaviours;
}

helper findBehaviourOfLifeline(behaviours : Set(Behaviour), lifelineName : String) : Behaviour {
	behaviours->forEach(behaviour) {
		if(behaviour.Lifeline.Name.=(lifelineName)) {
			return behaviour;
		}
	};
	
	return null;
}

helper getStatesOfBehaviour(behaviour : Behaviour) : Set(IOAutomaton::State) {
	var states : Set(IOAutomaton::State);
	behaviour.Block->forEach(block) {
		if(not containsStateWithName(states, block.PreState.Name)) {
			states += block.PreState-> map mapState();
		};
		if(not containsStateWithName(states, block.PostState.Name)) {
			states += block.PostState-> map mapState();
		};
	};
	
	return states;
}

helper containsStateWithName(states : Set(IOAutomaton::State), stateName : String) : Boolean {
	states->forEach(state) {
		if(state.Name.=(stateName)) {
			return true;
		}
	};
	
	return false;
}

helper containsInput(inputs : Set(IOAutomaton::Input), probeInput : IOAutomaton::Input) : Boolean {
	inputs->forEach(input) {
		if(input.Operation.Name = (probeInput.Operation.Name)) {
			return true;
		}
	};
	
	return false;
}

helper getInputsFromTransitions(transitions : Set(IOAutomaton::Transition)) : Set(IOAutomaton::Input) {
	var inputs : Set(IOAutomaton::Input);
	transitions->forEach(transition) {
		if(not containsInput(inputs, transition.Input)) {
			inputs += transition.Input;
		}
	};
	return inputs;
}

helper containsOutput(outputs : Set(IOAutomaton::Output), probeOutput : IOAutomaton::Output) : Boolean {
	outputs->forEach(output) {
		if(output.Operation.Name.=(probeOutput.Operation.Name)) {
			return true;
		}
	};
	
	return false;
}

helper getAutomatonState(states : Set(IOAutomaton::State), inputState : BehaviourProjection::State) : IOAutomaton::State {
	states->forEach(state) {
		if(state.Name.=(inputState.Name)) {
			return state;
		}
	};
	
	return null;
}

helper IOAutomaton::Activation::equalsBehaviourActivation(activation : BehaviourProjection::Activation) : Boolean {
	return self.Return.Name = activation.ReturnValue.Name 
		and self.Return.IsVoid = activation.ReturnValue.IsVoid 
		and self.Output->forAll(o1 | activation.OutMessage->exists(o2 | o1.Name = o2.Operation.Name 
			and o1.Operation.Name = o2.Operation.Name 
			and o1.Object.Name =    o2.Object.Name 
			and ((o1.Return = null and o2.ReturnValue = null) or 
				(o1.Return.Name =    o2.ReturnValue.Name and o1.Return.IsVoid =  o2.ReturnValue.IsVoid))))
		and activation.OutMessage->forAll(o1 | self.Output->exists(o2 | o2.Name = o1.Operation.Name 
			and o2.Operation.Name = o1.Operation.Name 
			and o2.Object.Name =    o1.Object.Name 
			and ((o2.Return = null and o1.ReturnValue = null) or 
				(o2.Return.Name =    o1.ReturnValue.Name and o2.Return.IsVoid =  o1.ReturnValue.IsVoid))));
}

mapping BehaviourProjection::State::mapState() : IOAutomaton::State {
	result.Name := self.Name;
}


mapping Behaviour::mapBehaviour() : Automaton {
	log("Mapping Behaviour to Automaton " + self.Lifeline.Name);
	
	result.Name := self.Lifeline.Name;
	
	result.Z := getStatesOfBehaviour(self);
	result.In := self.Block.InMessage.map mapInMessage();
	result.Out := self.Block.Activation.map mapActivation();
	result.Delta := self.Block->map mapBlock(result);
	result.Z0 := self.Block->at(1).PreState.map mapState();
}

mapping Block::mapBlock(automaton : IOAutomaton::Automaton) : Transition {
	result.PreState := getAutomatonState(automaton.Z, self.PreState);
	result.PostState := getAutomatonState(automaton.Z, self.PostState);
	result.Input := automaton.In->select(e | e.Operation.Name = self.InMessage.Operation.Name)->asSequence()->at(1);
	result.Activation := automaton.Out->select(e | e.equalsBehaviourActivation(self.Activation))->asSequence()->at(1);
	result.Name := result.Input.Name + " / " + result.Activation.Name;
}

mapping BehaviourProjection::InMessage::mapInMessage() : IOAutomaton::Input

when { not inputsAlreadyInserted->includes(self.Operation.Name) 
}{
	inputsAlreadyInserted := inputsAlreadyInserted->including(self.Operation.Name);
	result.Operation := self.Operation.map mapOperation();
	result.Name := result.Operation.Name;
}

mapping BehaviourProjection::Operation::mapOperation() : IOAutomaton::Operation {
	result.Name := self.Name;
}

mapping BehaviourProjection::Activation::mapActivation() : IOAutomaton::Activation

when { not outputsAlreadyInserted->exists(e | e.equalsBehaviourActivation(self))
}{
	var name : String;
	result.Output := self.OutMessage->map mapOutMessage();
	result.Output->forEach(outp) {
		name := name + outp.Name + ",";
	};
	result.Return := self.ReturnValue.map mapReturn();
	name := name + result.Return.Name;
	result.Name := name;
	outputsAlreadyInserted += result;
}

mapping BehaviourProjection::OutMessage::mapOutMessage() : IOAutomaton::Output {
	result.Operation := self.Operation.map mapOperation();
	result.Object := self.Object.map mapObject();
	result.Return := self.ReturnValue.map mapReturn();
	result.Name := "<" + result.Operation.Name + "," + result.Object.Name + "," + "TODO" + ">";
}
mapping BehaviourProjection::Object::mapObject() : IOAutomaton::Object {
	result.Name := self.Name;	
}
mapping BehaviourProjection::Return::mapReturn() : IOAutomaton::ReturnValue {
	result.Name := self.Name;
	result.IsVoid := self.IsVoid;
}
